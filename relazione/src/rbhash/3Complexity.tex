\def\baselinestretch{1}
\section{Studio complessit\`a}
\def\baselinestretch{1.66}
\thispagestyle{headings}
\indent Come detto precedentemente gli alberi Red Black hanno una complessit\`a temporale
nel \textbf{caso peggiore} al pi\`u equivalente ad $O(log_2 n)$ poich\'e bisogna scorrere tutto
l'albero in profondit\`a.\newline

\indent Le tabelle di hash a indirizzamento aperto, con doppia funzione di hash hanno complessit\`a temporali
prossime all'\textit{hashing 'ideale'}. Per poter assicurare che le due funzioni di hash producano
complessit\`a nel caso medio uguali a $O(1)$, si deve scegliere un valore della tavola di hash uguale ad
un numero primo o come potenza di due, e usare la seconda funzione di hash (quella che scandisce l'offset
dato dalle ispezioni successive) con un valore poco pi\`u piccolo di $m$ ($m-1$ o $m-2$).
In tal modo il doppio hashing usa $O(m^2)$ sequenze di ispezione,
perch\'e ogni coppia ($h_1(k), h_2(k)$) produce una distinta sequenza di ispezione.
Le \textbf{hashtable nel caso migliore}, ovvero non avendo nessuna collisione inseriscono,
cercano e cancellano i dati in $O(1)$.
Nel caso \textbf{peggiore} avremo un tempo massimo di $O(m)$,
dovuto alla scansione lineare di tutta la tavola di hash: ci\`o \`e  dovuto alla hashtable che si riempie
cio\`e quando il \textbf{ fattore di carico} (rapporto di elementi
inseriti e size della tavola) $\alpha$ tende a $1$.\newline

\indent Nella struttura dati \textbf{red-black hash} quando effettuiamo un \textbf{inserimento} andremo prima
ad effettuare una ricerca nell'albero rosso nero ($O(log_2n)$):
\begin{itemize}
    \item se esiste il nodo di chiave 1 allora
effettuiamo una ricerca nell'hash table tramite la chiave 2, e se possibile concludiamo l'inserimento.
Nel caso medio avremo una complessit\`a del tipo
$O(log_2n) + O(1) + O(1)$ e $O(log_2n) + O(m) + O(m)$ se l'hashtable ha un fattore di carico prossimo
all'1. In altri termini $\mathbf{O(log_2n)}$ e $\mathbf{O(m+log_2n)}$.;
    \item se invece il nodo di chiave 1 non esiste, dobbiamo allocare una hashtable, mappare la stringa alla chiave 2
e inserirla nell'albero: ci\`o porta una complessit\`a pari a $O(log_2n) + O(1) +  O(log_2n)$ ovvero 
$\mathbf{O(log_2n)}$.
\end{itemize}
L'operazione di \textbf{ricerca} impiega $\mathbf{O(m+log_2n)}$ nel caso in cui esista il nodo
con chiave 1 e la ricerca nella tavola hash restituisca l'indice in un tempo lineare; l'uso di tale indice 
serve per accedere al dato in $O(1)$. Nel caso migliore invece la ricerca avviene in
$\mathbf{O(log_2n)}$.\newline
La \textbf{cancellazione} ha complessit\`a uguali alle precendenti: si effettua una ricerca e
se l'hashtable ha solo un elemento allora si provvede a cancellare l'intero nodo dall'albero, altrimenti
si cancella solamente nell'hashtable: pertanto $\mathbf{O(log_2n)}$ oppure $\mathbf{O(m+log_2n)}$.
\newline
Tramite questo prospetto possiamo affermare che i casi peggiori sono dettati dalla tavola di hash e dipende
tutto dal suo fattore di carico.